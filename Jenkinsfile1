pipeline {
    agent any
    
    environment {
        SLACK_CHANNEL = '#purple'
        DOCKER_IMAGE = 'portfolio'
        DOCKER_TAG = "dev-${env.BUILD_NUMBER}"
        DEPLOY_PORT = '8060'  
    }
    
    triggers {
        pollSCM('* * * * *')  // V√©rification toutes les minutes
    }
    
    stages {
        stage('D√©tection Commit') {
            steps {
                script {
                    // R√©cup√©rer les infos du commit
                    def commitHash = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    def commitMessage = sh(script: 'git log -1 --pretty=%B', returnStdout: true).trim()
                    def author = sh(script: 'git log -1 --pretty=%an', returnStdout: true).trim()
                    
                    slackSend(
                        channel: "${env.SLACK_CHANNEL}",
                        color: "good",
                        message: """üöÄ NOUVEAU COMMIT D√âTECT√â - Build #${env.BUILD_NUMBER}
üìù Message: ${commitMessage}
üë§ Auteur: ${author}
üîó Commit: ${commitHash}
üåø Branch: ${env.GIT_BRANCH}"""
                    )
                }
            }
        }
    
        stage('Clone') {
            steps {
                script {
                    slackSend channel: "${env.SLACK_CHANNEL}", 
                             color: 'good', 
                             message: "üì• D√©but du clonage - Build #${env.BUILD_NUMBER}"
                    
                    echo "Clonage du d√©p√¥t de la branche dev..."
                    // Le checkout est d√©j√† fait automatiquement par Jenkins, on v√©rifie juste
                    sh 'git status'
                }
            }
            post {
                success {
                    script {
                        def commitInfo = sh(script: 'git log -1 --oneline', returnStdout: true).trim()
                        slackSend channel: "${env.SLACK_CHANNEL}", 
                                 color: 'good', 
                                 message: "‚úÖ CLONE R√âUSSI\nRepository: mon-portfolio"
                    }
                }
                failure {
                    slackSend channel:"${env.SLACK_CHANNEL}", 
                             color: 'danger', 
                             message: "‚ùå √âCHEC DU CLONE\nImpossible d'acc√©der au d√©p√¥t"
                }
            }
        }
        
        stage('Build') {
            steps {
                script {
                    echo "üî® Construction de l'image Docker du portfolio..."           
                    // Build de l'image Docker
                    docker.build("${env.DOCKER_IMAGE}:${env.DOCKER_TAG} "-f Dockerfile.txt ." ")
                }
            }
            post {
                success {
                    script {
                        def imageSize = sh(
                            script: "docker images ${env.DOCKER_IMAGE}:${env.DOCKER_TAG} ", 
                            returnStdout: true
                        ).trim()
                        
                        slackSend channel: "${env.SLACK_CHANNEL}", 
                                 color: 'good', 
                                 message: "‚úÖ BUILD R√âUSSI\nImage: ${env.DOCKER_IMAGE}:${env.DOCKER_TAG}\nTaille: ${imageSize}"
                    }
                }
                failure {
                    slackSend channel: "${env.SLACK_CHANNEL}", 
                             color: 'danger', 
                             message: "‚ùå √âCHEC DU BUILD\nErreur lors de la construction Docker"
                }
            }
        }
        
        stage('Deploy') {
            steps {
                script {
                    echo "üöÄ D√©ploiement du portfolio..."
                    
                    // Arr√™ter et supprimer l'ancien conteneur s'il existe
                    sh '''
                        echo "Nettoyage des anciens conteneurs..."
                        docker stop portfolio-dev || true
                        docker rm portfolio-dev || true
                    '''
                    
                    // Lancer le nouveau conteneur
                    sh """
                        docker run -d \
                            --name portfolio-dev \
                            -p ${env.DEPLOY_PORT}:80 \
                            ${env.DOCKER_IMAGE}:${env.DOCKER_TAG}
                    """
                    
                    // Attendre que l'application soit pr√™te
                    sleep 10
                    
                    // Test du d√©ploiement - CORRECTION DU PORT
                    sh "curl -f http://localhost:${env.DEPLOY_PORT} || exit 1"
                    
                    echo "‚úÖ D√©ploiement r√©ussi sur le port ${env.DEPLOY_PORT}"
                }
            }
            post {
                success {
                    slackSend channel: "${env.SLACK_CHANNEL}", 
                             color: 'good', 
                             message: "üéâ D√âPLOIEMENT R√âUSSI\nPortfolio disponible: http://localhost:${env.DEPLOY_PORT}\nConteneur: portfolio-dev\nImage: ${env.DOCKER_IMAGE}:${env.DOCKER_TAG}"
                }
                failure {
                    slackSend channel: "${env.SLACK_CHANNEL}", 
                             color: 'danger', 
                             message: "‚ùå √âCHEC DU D√âPLOIEMENT\nImpossible de d√©ployer le portfolio"
                    
                    // Nettoyage en cas d'√©chec
                    sh '''
                        docker stop portfolio-dev || true
                        docker rm portfolio-dev || true
                    '''
                }
            }
        }
    }
    
    // POST pour l'ensemble du pipeline - CORRECTEMENT PLAC√â
    post {
        always {
            echo "üèÅ Pipeline termin√© - R√©sultat: ${currentBuild.currentResult}"
            script {
                // Nettoyage des images temporaires
                sh '''
                    echo "Nettoyage des images Docker..."
                    docker images -f "dangling=true" -q | xargs -r docker rmi || true
                '''
            }
        }
        success {
            slackSend channel: "${env.SLACK_CHANNEL}", 
                     color: 'good', 
                     message: "üéä PIPELINE TERMIN√â - SUCC√àS\nBuild #${env.BUILD_NUMBER}\nDur√©e: ${currentBuild.durationString}\nD√©tails: ${env.BUILD_URL}"
        }
        failure {
            slackSend channel: "${env.SLACK_CHANNEL}", 
                     color: 'danger', 
                     message: "üí• PIPELINE TERMIN√â - √âCHEC\nBuild #${env.BUILD_NUMBER}\nDur√©e: ${currentBuild.durationString}\nD√©tails: ${env.BUILD_URL}"
        }
        unstable {
            slackSend channel: "${env.SLACK_CHANNEL}", 
                     color: 'warning', 
                     message: "‚ö†Ô∏è PIPELINE TERMIN√â - INSTABLE\nBuild #${env.BUILD_NUMBER}\nD√©tails: ${env.BUILD_URL}"
        }
    }
}
